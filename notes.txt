Tool architecture:

User runs 'gopar' executable with the same arguments as they would to 'go'. The
tool examines the source code to be built and creates a matching directory 
structure to store generated kernel files. The tool then does the source
generation. Finally, the tool invokes 'go' with the same arguments, but modifies
the GOPATH env variable to include the auto-generated files, as well as include
the gopar directory that contains the parallel runtime library.

Steps:
  - $ gopar [run|build|install] <main package>
  - Build function calls starting from main()
    - Determine call graph, and identify possible parallelism points
      - Tag non-parallelizable library calls
    - Record the work factor increase for loops to later calculate the number
        of threads to launch.
    - Deal with recursion
  - Pick the cutoff loop for parallelizing along each branch in the call graph
    - Analyze each loop as being independent, or recognize reductions and shared
        variables.
  - For each loop picked to be parallelized, copy all of the files in that
      package to the temporary directory
  - For each loop to be parallelized:
    - Modify the surrounding AST to correctly marshall data to/from OpenCL
    - Generate the OpenCL kernel
    - Include the call to the OpenCL kernel
  - Launch the underlying 'go' program with modified GOPATH env
    - <path to src/rtlib>:<path to generated src/>:<original path>

Go-to-C translation:
- Simple support, no interfaces/typecasting/etc
- Support for ordered channel writes within kernels (prefix sum prerun for idx)

Parallel kernel detection:
- Only range/simple for loops
  go func() {
    for i := 0 ; i < 7*6*5*4*3*2 ; i++ {
      c <- f(i)
    }
    done<- 1
  }()
  go func() {
    for i := range workchan {
      c <- f(i)
    }
    done<- 1
  }()
- The loop is parallelized, outer go code is run as normal. Only allow 1 loop
per goroutine launch? Guess not, no reason to, just check data dependencies
between kernel launches.


Runtime behavior: /gopar/rtlib
- detect channel write to parallelized kernel
- decide to batch/start timeout to 
